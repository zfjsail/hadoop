package InvertedIndex;

import java.io.IOException;
import java.util.*;
import java.util.Map.Entry;

import org.apache.hadoop.io.*;
import org.apache.hadoop.mapreduce.Reducer;

public class InvertedIndexReducer extends Reducer<Text, IntWritable, Text, Text> {

	private Text word1 = new Text();
	private Text word2 = new Text();
	String temp = new String();
	static Text CurrentItem = new Text(" ");
	static List<String> postingList = new ArrayList<String>();
	//static Map<Float, List<String>> rList = new TreeMap<Float, List<String>>().descendingMap();
	//static Map<String, List<Map<String, Map<Integer, Float>>>> rList = new TreeMap<String, List<Map<String, Map<Integer, Float>>>>();
	static Map<String, Integer> rfList = new TreeMap<String, Integer>();
	static Map<String, Integer> rnList = new TreeMap<String, Integer>();
	static Map<String, List<String>> author_map = new TreeMap<String, List<String>>();
	static List<Integer> occurList = new ArrayList<Integer>();

	
	@Override
	public void reduce(Text key, Iterable<IntWritable> values,
			Context context) throws IOException, InterruptedException {
		int sum = 0;
		temp = key.toString().split("~")[1];
		word1.set(temp + "~"+key.toString().split("~")[0]);
		//String num = key.toString().split("~")[3];
		String bname = key.toString().split("~")[2];
		for(IntWritable val : values) {
			sum += val.get();
		}
		word2.set(bname + ":" + sum);
		
		if(author_map.containsKey(temp)) {
			if(!author_map.get(temp).contains(bname))
				author_map.get(temp).add(bname);
		}
		else {
			List<String> l = new ArrayList<String>();
			l.add(bname);
			author_map.put(temp, l);
		}
		
		if(!CurrentItem.equals(word1) && !CurrentItem.equals(" ")) {
			long count = 0;
			for(int p : occurList) {
				//bname = p.substring(0, p.indexOf(":"));
				//count += Long.parseLong(p.substring(p.indexOf(":") + 1));
				count += p;
				
				/*
				if(!rnList.containsKey(CurrentItem.toString())) {
					List<String> l = new ArrayList<String>();
					l.add(bname);
					rnList.put(CurrentItem.toString(), l);
				}
				else if(!rnList.get(CurrentItem.toString()).contains(bname)) {
					rnList.get(CurrentItem.toString()).add(bname);
				}
				*/
			}
			//float avg = count/((float)postingList.size());
			if(count > 0) {
				rfList.put(CurrentItem.toString(), (int)count);
				rnList.put(CurrentItem.toString(), postingList.size());
			}
			postingList = new ArrayList<String>();
			occurList = new ArrayList<Integer>();
		}
		CurrentItem = new Text(word1);
		
		occurList.add(sum);
		//postingList.add(word2.toString());
		if(!postingList.contains(bname))
			postingList.add(bname);
	}
	
	public void cleanup(Context context) 
					throws IOException, InterruptedException {
		long count = 0;
		String bname;
		for(String p : postingList) {
			bname = p.substring(0, p.indexOf(":"));
			count += Long.parseLong(p.substring(p.indexOf(":") + 1));
			
			if(!rnList.containsKey(CurrentItem.toString())) {
				List<String> l = new ArrayList<String>();
				l.add(bname);
				rnList.put(CurrentItem.toString(), l);
			}
			else if(!rnList.get(CurrentItem.toString()).contains(bname)) {
				rnList.get(CurrentItem.toString()).add(bname);
			}
		}
		//float avg = count/((float)postingList.size());

		if(count > 0) {
			rfList.put(CurrentItem.toString(), (int)count);
		}

		postingList = new ArrayList<String>();
		for(Entry<String, Integer> entry : rfList.entrySet()) {
			  String key = entry.getKey();
			  int tf = entry.getValue();
			  int absize = rnList.get(key).size();
			  
			  String author = key.split("~")[0];
			  String word = key.split("~")[1];
			  int abtotal = author_map.get(author).size();
			  
			  double idf = Math.log(((double)abtotal) / (absize + 1));
			  
			 context.write(new Text(author + "\t" + word), new Text(tf + "\t" + idf));
		}
		
	}

}